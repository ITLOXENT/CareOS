#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[2]
OPENAPI_PATH = REPO_ROOT / "openapi.json"
TYPES_OUT = REPO_ROOT / "packages" / "types" / "src" / "openapi.ts"
SDK_OUT = REPO_ROOT / "packages" / "sdk" / "src" / "generated.ts"


def load_openapi() -> dict:
    return json.loads(OPENAPI_PATH.read_text())


def ts_type(schema: dict) -> str:
    if "$ref" in schema:
        ref_name = schema["$ref"].split("/")[-1]
        return ref_name
    schema_type = schema.get("type")
    if schema_type == "null":
        return "null"
    if schema_type == "string":
        return "string"
    if schema_type == "integer" or schema_type == "number":
        return "number"
    if schema_type == "boolean":
        return "boolean"
    if schema_type == "array":
        return f"{ts_type(schema.get('items', {}))}[]"
    if schema_type == "object":
        props = schema.get("properties", {})
        required = set(schema.get("required", []))
        fields = []
        for name in sorted(props.keys()):
            optional = "" if name in required else "?"
            fields.append(f"  {name}{optional}: {ts_type(props[name])};")
        if not fields:
            return "Record<string, unknown>"
        return "{\n" + "\n".join(fields) + "\n}"
    if isinstance(schema_type, list):
        if "null" in schema_type and len(schema_type) == 2:
            other = [t for t in schema_type if t != "null"][0]
            return f"{ts_type({'type': other})} | null"
    return "unknown"


def generate_types(spec: dict) -> str:
    schemas = spec.get("components", {}).get("schemas", {})
    lines = [
        "/* This file is generated by scripts/sdk/generate.py. */",
        "/* eslint-disable */",
        "",
    ]
    for name in sorted(schemas.keys()):
        schema = schemas[name]
        lines.append(f"export interface {name} {ts_type(schema)}")
        lines.append("")

    lines.append("export interface ApiPaths {")
    for path in sorted(spec.get("paths", {}).keys()):
        path_item = spec["paths"][path]
        methods = {k.upper(): v for k, v in path_item.items() if k.lower() in {"get"}}
        if not methods:
            continue
        lines.append(f'  "{path}": {{')
        for method, operation in sorted(methods.items()):
            response = (
                operation.get("responses", {})
                .get("200", {})
                .get("content", {})
                .get("application/json", {})
                .get("schema", {})
            )
            response_type = ts_type(response) if response else "unknown"
            lines.append(f"    {method}: {response_type};")
        lines.append("  };")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def generate_sdk(spec: dict) -> str:
    lines = [
        "/* This file is generated by scripts/sdk/generate.py. */",
        "import type { ApiPaths } from \"@careos/types\";",
        "",
        "export interface ClientOptions {",
        "  baseUrl: string;",
        "  fetch?: typeof fetch;",
        "}",
        "",
        "export function createClient(options: ClientOptions) {",
        "  const fetcher = options.fetch ?? fetch;",
        "  const baseUrl = options.baseUrl.replace(/\\/$/, \"\");",
        "",
        "  async function request<Path extends keyof ApiPaths & string, Method extends keyof ApiPaths[Path] & string>(",
        "    path: Path,",
        "    method: Method",
        "  ): Promise<ApiPaths[Path][Method]> {",
        "    const response = await fetcher(`${baseUrl}${path}`, { method: String(method) });",
        "    if (!response.ok) {",
        "      throw new Error(`Request failed: ${response.status}`);",
        "    }",
        "    return response.json() as Promise<ApiPaths[Path][Method]>;",
        "  }",
        "",
        "  return {",
    ]

    for path in sorted(spec.get("paths", {}).keys()):
        path_item = spec["paths"][path]
        for method in sorted(k for k in path_item.keys() if k.lower() == "get"):
            name = path.strip("/") or "root"
            safe = "".join(c if c.isalnum() else "_" for c in name)
            func_name = f"get_{safe}"
            lines.append(f"    {func_name}: () => request(\"{path}\", \"GET\"),")

    lines.append("  };")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def write_if_changed(path: Path, content: str) -> bool:
    existing = path.read_text() if path.exists() else ""
    if existing == content:
        return False
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content)
    return True


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--check", action="store_true", help="Check for drift only.")
    args = parser.parse_args()

    spec = load_openapi()
    types_content = generate_types(spec)
    sdk_content = generate_sdk(spec)

    if args.check:
        ok = True
        if not TYPES_OUT.exists() or TYPES_OUT.read_text() != types_content:
            print("packages/types/src/openapi.ts is out of date.")
            ok = False
        if not SDK_OUT.exists() or SDK_OUT.read_text() != sdk_content:
            print("packages/sdk/src/generated.ts is out of date.")
            ok = False
        return 0 if ok else 1

    changed = False
    changed |= write_if_changed(TYPES_OUT, types_content)
    changed |= write_if_changed(SDK_OUT, sdk_content)
    if changed:
        print("SDK files generated.")
    else:
        print("SDK files already up to date.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
